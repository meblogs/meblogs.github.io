{"meta":{"title":"小马哥随笔","subtitle":"","description":"","author":"小马哥","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"JavaScript基础语法——this","slug":"this_01","date":"2018-06-21T02:11:41.000Z","updated":"2021-02-20T06:32:18.653Z","comments":true,"path":"2018/06/21/this_01/","link":"","permalink":"http://example.com/2018/06/21/this_01/","excerpt":"","text":"什么是this 在传统面向对象的语言中，比如Java，this关键字用来表示当前对象本身，或当前对象的一个实例，通过this关键字可以获得当前对象的属性和调用方法。 在JavaScript中，this似乎表现地略有不同，这也是让人“讨厌”的地方~ ECMAScript规范中这样写：this关键字执行为当前执行环境的 ThisBinding。 MDN上这样写：在绝大多数情况下，函数的调用方式决定了this的值。 可以这样理解，在JavaScript中，this的指向是调用时决定的，而不是创建时决定的，这就会导致this的指向会让人迷惑，简单来说，this具有运行期绑定的特性。参考资料: 关于this 调用位置 首先需要理解调用位置，调用位置就是函数在代码中被调用的位置，而不是声明的位置。通过分析调用栈（到达当前执行位置所调用的所有函数）可以找到调用位置。 123456789101112 function baz()&#123; console.log(&quot;baz&quot;); bar();&#125;function bar()&#123; console.log(&quot;bar&quot;); foo();&#125;function foo()&#123; console.log(&quot;foo&quot;);&#125;baz(); 当我们调用baz()时，它会以此调用baz()→bar()→foo()。 对于foo()：调用位置是在bar()中。对于bar()：调用位置是在baz()中。而对于baz()：调用位置是全局作用域中。 可以看出，调用位置应该是当前正在执行的函数的前一个调用中。 全局上下文 在全局执行上下文中this都指代全局对象。 this等价于window对象 var === this. === winodw. 12345console.log(window === this); // truevar a = 1;this.b = 2;window.c = 3;console.log(a + b + c); // 6 在浏览器里面this等价于window对象，如果你声明一些全局变量，这些变量都会作为this的属性。 函数上下文 ##在函数内部，this的值取决于函数被调用的方式。 一、直接调用this指向全局变量。 1234function foo()&#123; return this;&#125;console.log(foo() === window); // true call()/apply()this 指向绑定的对象 123456789var person = &#123; name: &quot;axuebin&quot;, age: 25&#125;;function say(job)&#123; console.log(this.name+&quot;:&quot;+this.age+&quot; &quot;+job);&#125;say.call(person,&quot;FE&quot;); // axuebin:25say.apply(person,[&quot;FE&quot;]); // axuebin:25 可以看到，定义了一个say函数是用来输出name、age和job，其中本身没有name和age属性，我们将这个函数绑定到person这个对象上，输出了本属于person的属性，说明此时this是指向对象person的。 如果传入一个原始值（字符串、布尔或数字类型）来当做this的绑定对象， 这个原始值会被转换成它的对象形式（new String()），这通常被称为“装箱”。 call和apply从this的绑定角度上来说是一样的，唯一不同的是它们的第二个参数。 bind()this将永久地被绑定到了bind的第一个参数。 bind和call、apply有些相似,后两者会立即执行，而bind 返回一个新的函数，需要手动调用。 二、箭头函数所有的箭头函数都没有自己的this，都指向外层。ES6 箭头函数中的 this？你可能想多了（翻译）关于箭头函数this的理解几乎完全是错误的 #150 MDN中对于箭头函数这一部分是这样描述的：箭头函数会捕获其所在上下文的this值，作为自己的this值 123456789function Person(name)&#123; this.name = name; this.say = () =&gt; &#123; var name = &quot;xb&quot;; return this.name; &#125;&#125;var person = new Person(&quot;axuebin&quot;);console.log(person.say()); // axuebin 箭头函数常用语回调函数中，例如定时器中： 123456789function foo() &#123; setTimeout(()=&gt;&#123; console.log(this.a); &#125;,100)&#125;var obj = &#123; a: 2&#125;foo.call(obj); 附上MDN关于箭头函数this的解释：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#不绑定_this 三、作为对象的一个方法this指向调用函数的对象。 1234567var person = &#123; name: &quot;axuebin&quot;, getName: function()&#123; return this.name; &#125;&#125;console.log(person.getName()); // axuebin 这里有一个需要注意的地方。。。 123456789var name = &quot;xb&quot;;var person = &#123; name: &quot;axuebin&quot;, getName: function()&#123; return this.name; &#125;&#125;var getName = person.getName;console.log(getName()); // xb 发现this又指向全局变量了，这是为什么呢？还是那句话，this的指向得看函数调用时。 四、作为一个构造函数this被绑定到正在构造的新对象。也就是new 出来的实例 通过构造函数创建一个对象其实执行这样几个步骤： 创建新对象 将this指向这个对象 给对象赋值（属性、方法） 返回this 所以this就是指向创建的这个对象上。 12345678910function Person(name)&#123; this.name = name; this.age = 25; this.say = function()&#123; console.log(this.name + &quot;:&quot; + this.age); &#125;&#125;var person = new Person(&quot;axuebin&quot;);console.log(person.name); // axuebinperson.say(); // axuebin:25 五、作为一个DOM事件处理函数this指向触发事件的元素，也就是始事件处理程序所绑定到的DOM节点。 12345var ele = document.getElementById(&quot;id&quot;);ele.addEventListener(&quot;click&quot;,function(e)&#123; console.log(this); console.log(this === e.target); // true&#125;) 六、HTML标签内联事件处理函数this指向所在的DOM元素 &lt;button onclick=&quot;console.log(this);&quot;&gt;Click Me&lt;/button&gt; 总结如果要判断一个函数的this绑定，就需要找到这个函数的直接调用位置。然后可以顺序按照下面四条规则来判断this的绑定对象：1.由new调用：绑定到新创建的对象2.由call或apply、bind调用：绑定到指定的对象3.由上下文对象调用：绑定到上下文对象4.默认：全局对象 注意：箭头函数不使用上面的绑定规则，根据外层作用域来决定this，继承外层函数调用的this绑定。 相关链接: 全方位解读this … JavaScript深入之从ECMAScript规范解读this 一道常被人轻视的前端JS面试题 面试官问：JS的指向","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]}],"categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]}